# khai báo thư viện
import os
import cv2
import time
import calendar
import smtplib
import requests
import pygame
import subprocess
import json
import wikipedia
import configparser
from unidecode import unidecode
from tkinter import *
from datetime import datetime
from PIL import Image, ImageTk
from tkinter.scrolledtext import ScrolledText
from tkinter import Tk, ttk, LEFT, W, E, N, S, messagebox, filedialog, colorchooser, simpledialog, filedialog, Listbox, Scrollbar, WORD, END, scrolledtext
import speech_recognition as sr
import librosa
import soundfile as sf
import threading
from tqdm import tqdm 
# Tính năng 1: Đồng hồ và lịch
def clock():
    # Tạo cửa sổ chính
    root = Toplevel()
    root.title("1. Đồng hồ và lịch")
    tinh_nang_1 = ttk.Frame(root, padding=20)
    tinh_nang_1.grid()
    # Tạo các nhãn cho ngày, giờ và lịch
    hom_nay = ttk.Label(tinh_nang_1, text="", anchor="center", font=("Helvetica", 16))
    hom_nay.grid(column=0, row=0, columnspan=2, pady=5)
    thoi_gian = ttk.Label(tinh_nang_1, text="", anchor="center", font=("Helvetica", 24, "bold"))
    thoi_gian.grid(column=0, row=1, columnspan=2, pady=5)
    calendar_label = ttk.Label(tinh_nang_1, text="", anchor="center", justify=LEFT, font=("Courier New", 12))
    calendar_label.grid(column=0, row=2, columnspan=2, pady=5)
    def update_clock():
        # Lấy ngày và giờ hiện tại
        hom_nay_data = datetime.now().strftime("%d-%m-%Y")
        thoi_gian_data = datetime.now().strftime("%H:%M:%S")
        # Cập nhật các nhãn
        hom_nay.config(text=f"Ngày hôm nay: {hom_nay_data}")
        thoi_gian.config(text=f"Thời gian: {thoi_gian_data}")
        root.after(1000, update_clock)
    # Lấy lịch cả năm
    text_calendar = calendar.TextCalendar()
    year = datetime.now().year
    all_lich = text_calendar.formatyear(year)
    calendar_label.config(text=f"Lịch năm nay: {all_lich}")
    # Gọi hàm update_clock ban đầu để hiển thị đồng hồ ngay lập tức
    update_clock()
    root.mainloop()
# Tính năng 2: Máy ảnh
recording = False
video_writer = None
def camera():
    global recording, video_writer
    root = Toplevel()
    root.title("2. Máy ảnh")
    cap = cv2.VideoCapture(0)

    tinh_nang_2 = ttk.Frame(root, padding=20)
    tinh_nang_2.grid()
    label = Label(tinh_nang_2)
    label.grid(column=0, row=0, columnspan=2, sticky="ew")

    def update_frame():
        ret, frame = cap.read()
        if ret:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(frame)
            img_tk = ImageTk.PhotoImage(image=img)
            label.img_tk = img_tk
            label.config(image=img_tk)
            if recording and video_writer is not None:
                frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                video_writer.write(frame_bgr)
        root.after(10, update_frame)

    def on_closing():
        cap.release()
        if video_writer is not None:
            video_writer.release()
        root.destroy()

    def chup_anh():
        ret, frame = cap.read()
        if ret:
            filename = datetime.now().strftime("%Y%m%d_%H%M%S") + ".jpg"
            cv2.imwrite(filename, frame)
            print(f"Ảnh đã được lưu: {filename}")

    def quay_video():
        global recording, video_writer
        if not recording:
            recording = True
            filename = datetime.now().strftime("%Y%m%d_%H%M%S") + ".avi"
            fourcc = cv2.VideoWriter_fourcc(*'XVID')
            video_writer = cv2.VideoWriter(filename, fourcc, 20.0, (640, 480))
            print(f"Bắt đầu quay video: {filename}")
        else:
            recording = False
            if video_writer is not None:
                video_writer.release()
                print("Dừng quay video")
            video_writer = None

    def mo_kho_luu_tru():
        os.startfile(os.getcwd())

    ttk.Button(tinh_nang_2, text="Chụp ảnh", command=chup_anh).grid(column=0, row=1, columnspan=2, sticky="ew")
    ttk.Button(tinh_nang_2, text="Quay video", command=quay_video).grid(column=0, row=2, columnspan=2, sticky="ew")
    ttk.Button(tinh_nang_2, text="Kho lưu trữ", command=mo_kho_luu_tru).grid(column=0, row=3, columnspan=2, sticky="ew")

    root.protocol("WM_DELETE_WINDOW", on_closing)
    update_frame()
    root.mainloop()
# Tính năng 3: Gửi thư  
def gui_thu():
    SENDER_EMAIL = "ungdungthu3@gmail.com"
    SENDER_PASSWORD = "dvmq ponq gplj awdq"
    def send_email():
        try:
            server = smtplib.SMTP("smtp.gmail.com", 587)
            server.starttls()
            server.login(SENDER_EMAIL, SENDER_PASSWORD)
            email_message = f"Subject: {subject_entry.get()}\n\n{message_text.get('1.0', END)}".encode("utf-8")
            server.sendmail(SENDER_EMAIL, recipient_entry.get(), email_message)
            server.quit()
            messagebox.showinfo("Thành công", "Email đã được gửi!")
        except Exception as e:
            messagebox.showerror("Lỗi", f"Không thể gửi email: {e}")

    root = Toplevel()
    root.title("3.Gửi thư")

    Label(root, text="Người gửi:").grid(row=0, column=0)
    Label(root, text=SENDER_EMAIL).grid(row=0, column=1)

    Label(root, text="Người nhận:").grid(row=1, column=0)
    recipient_entry = Entry(root, width=40); recipient_entry.grid(row=1, column=1)

    Label(root, text="Chủ đề:").grid(row=2, column=0)
    subject_entry = Entry(root, width=40); subject_entry.grid(row=2, column=1)

    Label(root, text="Nội dung:").grid(row=3, column=0)
    message_text = Text(root, height=10, width=50); message_text.grid(row=3, column=1)

    Button(root, text="Gửi", command=send_email).grid(row=4, column=1)
    
    root.mainloop()
# Tính năng 4: Máy tính
def may_tinh():
    root = Toplevel()
    root.title("4. Máy tính")
    root.resizable(False, False)

    expression = ""     # Biến này để lưu trữ biểu thức hiện tại

    # Hàm cập nhật ô nhập liệu
    def update_entry(value):
        nonlocal expression
        expression += str(value)
        entry.delete(0, END)
        entry.insert(0, expression)
    # Hàm xóa toàn bộ ô nhập liệu 
    def clear_entry():
        nonlocal expression
        expression = ""
        entry.delete(0, END)
    # Hàm tính toán kết quả
    def calculate_result():
        nonlocal expression
        try:
            # Thay thế các ký hiệu toán học với người dùng thành toán tử Python
            eval_expression = expression.replace("x", "*").replace(":", "/").replace(",", ".")
            # Đánh giá biểu thức
            result = str(eval(eval_expression))
            entry.delete(0, END)
            entry.insert(0, result)
            expression = result # Lưu kết quả để có thể tiếp tục tính toán
        except Exception as e:
            # Hiển thị thông báo lỗi
            messagebox.showerror("Lỗi", "Biểu thức không hợp lệ hoặc lỗi: " + str(e))
            expression = "" # Đặt lại biểu thức khi có lỗi
    # Hàm xóa ký tự cuối cùng 
    def delete_last_char():
        nonlocal expression
        expression = expression[:-1] # Cắt bỏ ký tự cuối cùng
        entry.delete(0, END)
        entry.insert(0, expression)
    # Khung chứa các phím
    tinh_nang_4 = ttk.Frame(root, padding="10 10 10 10")
    tinh_nang_4.grid(row=0, column=0, sticky=(N, W, E, S))
    root.grid_columnconfigure(0, weight=1)
    root.grid_rowconfigure(0, weight=1)
    # Ô nhập liệu hiển thị biểu thức và kết quả
    entry = Entry(tinh_nang_4, width=25, font=('Arial', 14), justify='right')
    entry.grid(row=0, column=0, columnspan=5, pady=10, ipadx=5, ipady=5)
    # Các nút hàng 1
    ttk.Button(tinh_nang_4, text="AC", command=clear_entry, width=5).grid(column=0, row=1, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="(", command=lambda: update_entry("("), width=5).grid(column=1, row=1, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text=")", command=lambda: update_entry(")"), width=5).grid(column=2, row=1, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text=":", command=lambda: update_entry(":"), width=5).grid(column=3, row=1, padx=2, pady=2) 
    # Các nút hàng 2
    ttk.Button(tinh_nang_4, text="7", command=lambda: update_entry("7"), width=5).grid(column=0, row=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="8", command=lambda: update_entry("8"), width=5).grid(column=1, row=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="9", command=lambda: update_entry("9"), width=5).grid(column=2, row=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="x", command=lambda: update_entry("x"), width=5).grid(column=3, row=2, padx=2, pady=2) 
    # Các nút hàng 3
    ttk.Button(tinh_nang_4, text="4", command=lambda: update_entry("4"), width=5).grid(column=0, row=3, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="5", command=lambda: update_entry("5"), width=5).grid(column=1, row=3, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="6", command=lambda: update_entry("6"), width=5).grid(column=2, row=3, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="-", command=lambda: update_entry("-"), width=5).grid(column=3, row=3, padx=2, pady=2) 
    # Các nút hàng 4
    ttk.Button(tinh_nang_4, text="1", command=lambda: update_entry("1"), width=5).grid(column=0, row=4, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="2", command=lambda: update_entry("2"), width=5).grid(column=1, row=4, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="3", command=lambda: update_entry("3"), width=5).grid(column=2, row=4, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="+", command=lambda: update_entry("+"), width=5).grid(column=3, row=4, padx=2, pady=2) 
    # Các nút hàng 5
    ttk.Button(tinh_nang_4, text="0", command=lambda: update_entry("0"), width=11).grid(column=0, row=5, columnspan=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text=".", command=lambda: update_entry("."), width=5).grid(column=2, row=5, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="=", command=calculate_result, width=5).grid(column=3, row=5, padx=2, pady=2)
    # Nút xóa ký tự cuối cùng
    ttk.Button(tinh_nang_4, text="Xóa", command=delete_last_char, width=5).grid(column=4, row=1, padx=2, pady=2)
    root.mainloop()
# Tính năng 5: Chuyển âm thanh thành văn bản
def chuyen_am_thanh_thanh_van_ban():
    def update_progress(message):
        text_area.delete(1.0, END)
        text_area.insert(END, message + "\n")
        text_area.update_idletasks() # Đảm bảo giao diện người dùng cập nhật ngay lập tức

    def convert_audio_to_text(file_path=None, language="vi-VN", use_microphone=False):
        """
        Chuyển đổi một file âm thanh (MP3) hoặc giọng nói trực tiếp từ micro
        thành văn bản. Hiển thị tiến trình và xử lý lỗi.

        Args:
            file_path (str, optional): Đường dẫn đến file MP3. Bắt buộc nếu use_microphone là False.
            language (str, optional): Mã ngôn ngữ cho nhận dạng giọng nói (ví dụ: "vi-VN", "en-US").
            use_microphone (bool, optional): Nếu True, sử dụng micro để nhập; ngược lại, sử dụng file_path.
        """
        recognizer = sr.Recognizer()

        try:
            update_progress("Đang xử lý âm thanh...")

            if use_microphone:
                with sr.Microphone() as source:
                    update_progress("Nói vào micro...")
                    # Điều chỉnh tiếng ồn xung quanh trước khi lắng nghe
                    recognizer.adjust_for_ambient_noise(source)
                    # Lắng nghe đầu vào âm thanh từ micro
                    recorded_data = recognizer.listen(source)
            else:
                if not file_path:
                    update_progress("Lỗi: Không có đường dẫn file MP3.")
                    return

                update_progress("Đang tải file MP3 và chuyển đổi...")
                # Tải MP3 bằng librosa, giữ nguyên tốc độ mẫu gốc
                y, sr_rate = librosa.load(file_path, sr=None)
                # Ghi vào một file WAV tạm thời vì SpeechRecognition hoạt động tốt nhất với WAV
                sf.write("temp_audio.wav", y, sr_rate)

                # Mô phỏng thanh tiến trình cho quá trình xử lý file
                for i in range(1, 11): # Từ 10% đến 100%
                    update_progress(f"Tiến trình tải và xử lý: {i * 10}%")
                    time.sleep(0.1) # Tạm dừng nhỏ để hiển thị cập nhật tiến trình

                with sr.AudioFile("temp_audio.wav") as source:
                    # Ghi lại toàn bộ file âm thanh
                    recorded_data = recognizer.record(source)

            update_progress("Đang nhận dạng giọng nói... (Quá trình này có thể mất một chút thời gian)")
            # Sử dụng API Google Web Speech để nhận dạng
            text = recognizer.recognize_google(recorded_data, language=language)

            update_progress("Hoàn tất! Dưới đây là văn bản:")
            text_area.insert(END, f"\n{text}\n")
        except sr.UnknownValueError:
            update_progress("Không thể nhận dạng giọng nói. Vui lòng thử lại.")
        except sr.RequestError as e:
            update_progress(f"Không thể kết nối với dịch vụ nhận dạng giọng nói; {e}")
        except FileNotFoundError:
            update_progress("Lỗi: Không tìm thấy file âm thanh.")
        except Exception as e:
            # Bắt bất kỳ lỗi không mong muốn nào khác
            update_progress(f"Lỗi: {e}")

    def select_mp3_file(language="vi-VN"):
        """
        Mở hộp thoại file để chọn file MP3 và sau đó
        bắt đầu một luồng mới để chuyển đổi nó thành văn bản.

        Args:
            language (str): Mã ngôn ngữ cho nhận dạng giọng nói.
        """
        # Yêu cầu người dùng chọn một file MP3
        file_path = filedialog.askopenfilename(
            title="Chọn file MP3",
            filetypes=[("MP3 files", "*.mp3"), ("Tất cả file", "*.*")]
        )
        if file_path:
            # Chạy quá trình chuyển đổi trong một luồng riêng biệt để giữ cho GUI phản hồi
            threading.Thread(target=convert_audio_to_text,
                             args=(file_path, language, False)).start()

    def start_microphone_recognition(language="vi-VN"):
        """
        Bắt đầu một luồng mới để nhận dạng giọng nói từ micro.

        Args:
            language (str): Mã ngôn ngữ cho nhận dạng giọng nói.
        """
        # Chạy nhận dạng micro trong một luồng riêng biệt
        threading.Thread(target=convert_audio_to_text,
                         args=(None, language, True)).start()

    # Thiết lập cửa sổ Tkinter chính
    root = Toplevel()
    root.title("Chuyển âm thanh thành văn bản")
    root.geometry("700x500") # Cửa sổ lớn hơn một chút

    # Cấu hình lưới để đáp ứng
    root.grid_rowconfigure(2, weight=1)
    root.grid_columnconfigure(0, weight=1)
    root.grid_columnconfigure(1, weight=1)

    # Khung chứa các nút
    button_frame = Frame(root, padx=10, pady=10)
    button_frame.grid(row=0, column=0, columnspan=2, pady=10, padx=10, sticky="ew")
    button_frame.grid_columnconfigure(0, weight=1)
    button_frame.grid_columnconfigure(1, weight=1)
    button_frame.grid_columnconfigure(2, weight=1)
    button_frame.grid_columnconfigure(3, weight=1)


    # Các nút để chọn file MP3 (tiếng Việt và tiếng Anh)
    select_button_vi = Button(button_frame, text="Chọn File MP3 (Tiếng Việt)",
                              command=lambda: select_mp3_file("vi-VN"),
                              font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    select_button_vi.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

    select_button_en = Button(button_frame, text="Chọn File MP3 (Tiếng Anh)",
                              command=lambda: select_mp3_file("en-US"),
                              font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    select_button_en.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    # Các nút để nhập từ Micro (tiếng Việt và tiếng Anh)
    mic_button_vi = Button(button_frame, text="Nhận dạng Micro (Tiếng Việt)",
                           command=lambda: start_microphone_recognition("vi-VN"),
                           font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    mic_button_vi.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

    mic_button_en = Button(button_frame, text="Nhận dạng Micro (Tiếng Anh)",
                           command=lambda: start_microphone_recognition("en-US"),
                           font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    mic_button_en.grid(row=1, column=1, padx=5, pady=5, sticky="ew")

    # Widget ScrolledText để hiển thị kết quả và tiến trình
    text_area = scrolledtext.ScrolledText(root, wrap=WORD, width=70, height=15,
                                          font=("Arial", 12), bg="#F8F8F8", fg="#333333",
                                          relief="sunken", borderwidth=2)
    text_area.grid(row=2, column=0, padx=10, pady=10, columnspan=2, sticky="nsew")
    text_area.insert(END, "Chào mừng! Nhấn một trong các nút trên để bắt đầu chuyển đổi âm thanh thành văn bản.\n")

    # Bắt đầu vòng lặp sự kiện Tkinter
    root.mainloop()
# Tính năng 6: Tìm kiếm thông tin
def tim_kiem_thong_tin():
    wikipedia.set_lang("vi")
    def lay_thong_tin():
        noi_dung_tim_kiem = o_nhap.get()
        if not noi_dung_tim_kiem:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, "Vui lòng nhập từ khóa tìm kiếm.")
            return

        try:
            tom_tat = wikipedia.summary(noi_dung_tim_kiem) 
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, tom_tat)
        except wikipedia.exceptions.PageError:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, f"Rất tiếc, tôi không tìm thấy thông tin về '{noi_dung_tim_kiem}'. Vui lòng thử từ khóa khác.")
        except wikipedia.exceptions.DisambiguationError as e:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, f"'{noi_dung_tim_kiem}' có thể có nhiều nghĩa. Vui lòng cụ thể hơn. Các lựa chọn: {e.options[:5]}...")
        except Exception as e:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, f"Đã xảy ra lỗi: {e}")

    # Tạo cửa sổ chính
    cua_so = Tk()
    cua_so.title("6.Tìm kiếm thông tin")
    cua_so.geometry("600x400")

    # Cấu hình trọng số cho grid để các cột và hàng có thể giãn nở
    cua_so.grid_columnconfigure(0, weight=1) # Làm cho cột 0 có thể giãn ngang
    cua_so.grid_rowconfigure(2, weight=1)   # Làm cho hàng 2 (chứa ô hiển thị kết quả) có thể giãn dọc

    # Tạo và đặt các widget sử dụng .grid()
    nhan_huong_dan = Label(cua_so, text="Nhập nội dung bạn muốn tìm hiểu:")
    nhan_huong_dan.grid(row=0, column=0, padx=10, pady=10, sticky="w") 

    o_nhap = Entry(cua_so, width=50)
    o_nhap.grid(row=1, column=0, padx=10, pady=5, sticky="ew") 
    o_nhap.bind("<Return>", lambda event=None: lay_thong_tin()) 

    nut_tim_kiem = Button(cua_so, text="Tìm kiếm", command=lay_thong_tin)
    nut_tim_kiem.grid(row=1, column=0, padx=10, pady=5, sticky="e") 

    o_ket_qua = ScrolledText(cua_so, wrap=WORD, width=70, height=15)
    o_ket_qua.grid(row=2, column=0, padx=10, pady=10, sticky="nsew") 
    cua_so.mainloop()
# Tính năng 7: Đồng hồ đếm ngược
def dem_nguoc():
    def start_countdown():
        try:
            seconds = int(entry.get())
            if seconds < 0:
                raise ValueError("Thời gian không thể âm.")
            countdown(seconds)
        except ValueError as e:
            messagebox.showerror("Lỗi", f"Vui lòng nhập một số hợp lệ: {e}")

    def countdown(seconds):
        if seconds >= 0:
            label.config(text=f"Đếm ngược: {seconds} giây")
            root.after(1000, countdown, seconds - 1)
        else:
            label.config(text="Hết giờ!")

    root = Toplevel()
    root.title("7. Đồng hồ đếm ngược")
    root.resizable(False, False)
    ttk.Label(root, text="Nhập thời gian (giây):").grid(column=0, row=0)
    entry = ttk.Entry(root); entry.grid(column=1, row=0)
    ttk.Button(root, text="Bắt đầu", command=start_countdown).grid(column=2, row=0)
    label = ttk.Label(root, text="Đếm ngược: 0 giây", font=("Helvetica", 16))
    label.grid(column=0, row=1, columnspan=3)    
# Tính năng 8: Máy phát nhạc
pygame.mixer.init() 
current_file = None
music_list = []
playing_index = -1
paused = False
root = None
listbox = None
file_label = None
play_pause_button = None
def may_phat_nhac_va_video():

    def load_music_list():      # Tải danh sách nhạc từ tệp JSON
        global music_list
        if os.path.exists("music_list.json"):
            with open("music_list.json", "r", encoding='utf-8') as f:
                try:
                    music_list = json.load(f)
                except json.JSONDecodeError:
                    music_list = []
            # Lọc bỏ các đường dẫn không tồn tại để tránh lỗi
                music_list = [path for path in music_list if os.path.exists(path)]

    def save_music_list():      #Lưu danh sách nhạc hiện tại vào tệp JSON
        global music_list
        with open("music_list.json", "w", encoding='utf-8') as f:
            json.dump(music_list, f, indent=4)

    def update_listbox():       #Cập nhật nội dung của widget listbox.
        global listbox
        listbox.delete(0,END)
        for i, path in enumerate(music_list):
            listbox.insert(END, f"{i+1}. {os.path.basename(path)}")
        highlight_playing_song()

    def highlight_playing_song():       # Đánh dấu bài hát đang phát trong listbox.
        global listbox, playing_index
        listbox.selection_clear(0,END)
        if 0 <= playing_index < len(music_list):
            listbox.selection_set(playing_index)
            listbox.see(playing_index)

    def add_to_music_list():        # Mở hộp thoại tệp để thêm các tệp nhạc vào danh sách phát.
        global music_list
        files_selected = filedialog.askopenfilenames(title="Chọn File Nhạc", filetypes=[("File nhạc (MP3, WAV)", "*.mp3;*.wav"), ("Tất cả", "*.*")])
        if files_selected:
            for file_path in files_selected:
                if file_path not in music_list: # Tránh thêm các bài hát trùng lặp
                    music_list.append(file_path)
            update_listbox()
            save_music_list()

    def remove_selected_from_list(event=None):      # Xóa các bài hát đã chọn khỏi danh sách phát.
        global music_list, playing_index, current_file, file_label
        selected_indices = listbox.curselection()
        if not selected_indices:
            messagebox.showinfo("Thông báo", "Vui lòng chọn bài hát để xóa.")
            return
    # Sắp xếp các chỉ mục để xóa theo thứ tự giảm dần để tránh thay đổi chỉ mục khi xóa
        indices_to_remove = sorted(list(selected_indices), reverse=True)
    # Đếm số lượng bài hát bị xóa *trước* bài hát đang phát để điều chỉnh playing_index
        removed_before_playing_count = 0
        original_playing_index = playing_index # Lưu chỉ mục gốc để so sánh
        for idx in indices_to_remove:
            if idx == original_playing_index: # Nếu bài hát đang phát bị xóa
                pygame.mixer.music.stop()
                current_file = None
                playing_index = -1 # Đặt lại playing_index
                file_label.config(text="Chưa có file nào được chọn")
                break # Bài hát đang phát đã được xử lý, không cần kiểm tra thêm
            if idx < original_playing_index:
                removed_before_playing_count += 1
    # Xóa các bài hát khỏi danh sách
        for index in indices_to_remove:
            del music_list[index]
    # Điều chỉnh playing_index sau khi xóa
        if playing_index != -1: # Nếu vẫn còn bài hát đang phát (tức là không bị xóa)
            playing_index -= removed_before_playing_count
    # Đảm bảo playing_index nằm trong giới hạn hợp lệ
            if playing_index >= len(music_list):
                playing_index = len(music_list) - 1 if len(music_list) > 0 else -1
            elif playing_index < 0 and len(music_list) > 0:
                playing_index = 0 # Đặt lại về bài hát đầu tiên nếu nó trở thành âm và vẫn còn bài hát
            elif len(music_list) == 0:
                playing_index = -1
        update_listbox()
        save_music_list()
        highlight_playing_song()

    def play_selected_from_list(event=None):        # Phát bài hát được chọn trong listbox.
        global playing_index, music_list
        selected_indices = listbox.curselection()
        if not selected_indices:
            return
        index = selected_indices[0]
        if 0 <= index < len(music_list):
            playing_index = index
            open_file(music_list[index])
            highlight_playing_song()

    def play_next():        # Phát bài hát tiếp theo trong danh sách phát.
        global music_list, playing_index
        if not music_list:
            messagebox.showinfo("Thông báo", "Danh sách phát trống.")
            return
        playing_index = (playing_index + 1) % len(music_list)
        open_file(music_list[playing_index])
        highlight_playing_song()

    def play_previous(): #Phát bài hát trước đó trong danh sách phát.
        global music_list, playing_index
        if not music_list:
            messagebox.showinfo("Thông báo", "Danh sách phát trống.")
            return
        playing_index = (playing_index - 1 + len(music_list)) % len(music_list)
        open_file(music_list[playing_index])
        highlight_playing_song()

    def select_and_open_file():
        global playing_index
        file_selected = filedialog.askopenfilenames(
            title="Chọn file",
            filetypes=[
                ("Tất cả file media", "*.mp3;*.wav;*.mp4;*.avi;*.mkv"),
                ("File nhạc (MP3, WAV)", "*.mp3;*.wav"),
                ("File video (MP4, AVI, MKV)", "*.mp4;*.avi;*.mkv"),
                ("Tất cả", "*.*")
            ]
        )
        if file_selected:
            playing_index = -1
            open_file(file_selected[0])  
            highlight_playing_song() 

    def open_file(file_path):       # Mở và phát tệp media đã chỉ định.
        global current_file, file_label, music_list, playing_index
        if not os.path.exists(file_path):
            messagebox.showerror("Lỗi", f"File không tồn tại: {file_path}")
        # Nếu tệp không tồn tại trong danh sách phát, hãy xóa nó
            if file_path in music_list:
                music_list.remove(file_path)
                update_listbox()
                save_music_list()
            current_file = None
            file_label.config(text="Chưa có file nào được chọn")
            return

        current_file = file_path
        file_name = os.path.basename(file_path)
        file_label.config(text=f"Đang phát: {file_name}")

        try:
            if file_path.lower().endswith(('.mp3', '.wav')):
                play_music(file_path)
            else:
                pygame.mixer.music.stop()
            # Sử dụng lệnh dành riêng cho từng hệ điều hành để mở các loại media khác
                if os.name == 'nt':  # Đối với Windows
                    os.startfile(file_path)
                elif os.uname().sysname == 'Darwin':  # Đối với macOS
                    subprocess.Popen(['open', file_path])
                else:  # Đối với Linux/Unix
                    subprocess.Popen(['xdg-open', file_path])
        except Exception as e:
            messagebox.showerror("Lỗi mở file", f"Lỗi: {e}")
            current_file = None
            file_label.config(text="Chưa có file nào được chọn")

    def play_music(music_path):     # Tải và phát tệp nhạc bằng pygame.mixer.
        global paused, play_pause_button, current_file, music_list, playing_index, root
        try:
            pygame.mixer.music.load(music_path)
            pygame.mixer.music.play()
            paused = False
            play_pause_button.config(text="Tạm Dừng")
            pygame.mixer.music.set_endevent(pygame.USEREVENT)
            root.after(100, check_music_end) # Bắt đầu kiểm tra xem bài hát đã kết thúc chưa
        except pygame.error as e:
            messagebox.showerror("Lỗi phát nhạc", f"Không thể phát nhạc: {e}")
            current_file = None
            file_label.config(text="Chưa có file nào được chọn")
        # Nếu bài hát có vấn đề là từ danh sách phát, hãy xóa nó
            if playing_index != -1 and music_list[playing_index] == music_path:
                del music_list[playing_index]
                update_listbox()
                save_music_list()
                playing_index = -1

    def check_music_end():      # Kiểm tra xem nhạc hiện tại đã kết thúc chưa và phát bài hát tiếp theo nếu có.
        global playing_index, music_list, current_file, file_label, root

        for event in pygame.event.get():
            if event.type == pygame.USEREVENT:
                if playing_index != -1 and playing_index < len(music_list) - 1:
                    play_next()
                else:
                # Kết thúc danh sách phát hoặc phát một bài hát duy nhất
                    pygame.mixer.music.stop()
                    current_file = None
                    file_label.config(text="Đã phát hết danh sách")
                    playing_index = -1
                    highlight_playing_song()
                return # Đã xử lý sự kiện, dừng kiểm tra trong lần lặp này

    # Tiếp tục kiểm tra chỉ khi nhạc đang bận hoặc tạm dừng
        if pygame.mixer.music.get_busy() or pygame.mixer.music.get_paused():
            root.after(100, check_music_end)

    def toggle_play_pause():        # Chuyển đổi trạng thái phát/tạm dừng của nhạc hiện tại.
        global current_file, music_list, playing_index, paused, play_pause_button
        if not current_file:
            if music_list:
                playing_index = 0
                open_file(music_list[playing_index])
                highlight_playing_song()
            else:
                messagebox.showinfo("Thông báo", "Vui lòng chọn một file nhạc trước.")
            return
        if paused:
            pygame.mixer.music.unpause()
            play_pause_button.config(text="Tạm Dừng")
            paused = False
        else:
            pygame.mixer.music.pause()
            play_pause_button.config(text="Tiếp Tục")
            paused = True

    def on_closing():       # Xử lý sự kiện đóng cửa sổ, lưu danh sách phát và dừng nhạc.
        global root
        save_music_list()
        pygame.mixer.music.stop()
        root.destroy()

    global root, listbox, file_label, play_pause_button

    root = Toplevel()
    root.title("8. Phát nhạc và video")
    tinh_nang_8 = ttk.Frame(root, padding=10)
    tinh_nang_8.grid(row=0, column=0, sticky="nsew")

    root.grid_rowconfigure(0, weight=1)
    root.grid_columnconfigure(0, weight=1)

    load_music_list()

    # --- Các phần tử giao diện người dùng ---

    # Nhãn tệp hiện tại
    file_label = Label(tinh_nang_8, text="Chưa có file nào được chọn", anchor="w")
    file_label.grid(row=0, column=0, columnspan=4, sticky="ew", pady=(0, 10))

    # Khung nút
    button_frame = ttk.Frame(tinh_nang_8)
    button_frame.grid(row=1, column=0, columnspan=4, pady=(0, 10))
    # Cấu hình các cột trong button_frame để mở rộng đều
    button_frame.grid_columnconfigure(0, weight=1)
    button_frame.grid_columnconfigure(1, weight=1)
    button_frame.grid_columnconfigure(2, weight=1)
    button_frame.grid_columnconfigure(3, weight=1)

    play_pause_button = ttk.Button(button_frame, text="Phát", command=toggle_play_pause)
    play_pause_button.grid(row=0, column=0, padx=5, sticky="ew")

    prev_button = ttk.Button(button_frame, text="Bài Trước", command=play_previous)
    prev_button.grid(row=0, column=1, padx=5, sticky="ew")

    next_button = ttk.Button(button_frame, text="Bài Kế", command=play_next)
    next_button.grid(row=0, column=2, padx=5, sticky="ew")

    open_file_button = ttk.Button(button_frame, text="Mở File", command=select_and_open_file)
    open_file_button.grid(row=0, column=3, padx=5, sticky="ew")

    # Nhãn danh sách phát
    playlist_label = ttk.Label(tinh_nang_8, text="Danh sách phát:", anchor="w")
    playlist_label.grid(row=2, column=0, columnspan=4, sticky="ew", pady=(10, 5))

    # Listbox cho danh sách nhạc
    listbox_frame = ttk.Frame(tinh_nang_8)
    listbox_frame.grid(row=3, column=0, columnspan=4, sticky="nsew")
    tinh_nang_8.grid_rowconfigure(3, weight=1)
    tinh_nang_8.grid_columnconfigure(0, weight=1) # Đảm bảo khung listbox mở rộng

    listbox = Listbox(listbox_frame, selectmode="extended")
    listbox.pack(side="left", fill="both", expand=True)

    scrollbar = Scrollbar(listbox_frame, orient="vertical", command=listbox.yview)
    scrollbar.pack(side="right", fill="y")
    listbox.config(yscrollcommand=scrollbar.set)

    # Ràng buộc double click để phát bài hát đã chọn
    listbox.bind("<Double-Button-1>", play_selected_from_list)

    # Các nút điều khiển danh sách phát
    playlist_button_frame = ttk.Frame(tinh_nang_8)
    playlist_button_frame.grid(row=4, column=0, columnspan=4, pady=(10, 0))
    # Cấu hình các cột trong playlist_button_frame
    playlist_button_frame.grid_columnconfigure(0, weight=1)
    playlist_button_frame.grid_columnconfigure(1, weight=1)


    add_to_list_button = ttk.Button(playlist_button_frame, text="Thêm vào DS", command=add_to_music_list)
    add_to_list_button.grid(row=0, column=0, padx=5, sticky="ew")

    remove_from_list_button = ttk.Button(playlist_button_frame, text="Xóa khỏi DS", command=remove_selected_from_list)
    remove_from_list_button.grid(row=0, column=1, padx=5, sticky="ew")

    # Cập nhật listbox ban đầu
    update_listbox()

    # Giao thức đóng cửa sổ
    root.protocol("WM_DELETE_WINDOW", on_closing)

    root.mainloop()
# Tính năng 9: Viết văn bản
def van_ban():
    root = Toplevel()
    root.title("9. Viết văn bản")
    text_area = Text(root, wrap="word", font=("Arial", 12))
    text_area.pack(expand=True, fill="both")
    
    def save_file():
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
        if file_path:
            with open(file_path, "w", encoding="utf-8") as file:
                file.write(text_area.get("1.0", END))
            messagebox.showinfo("Thông báo", "Tệp đã được lưu thành công.")
    
    def open_file():
        file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
        if file_path:
            with open(file_path, "r", encoding="utf-8") as file:
                text_area.delete("1.0", END)
                text_area.insert("1.0", file.read())
    
    ttk.Button(root, text="Lưu tệp", command=save_file).pack(side=LEFT, padx=5, pady=5)
    ttk.Button(root, text="Mở tệp", command=open_file).pack(side=LEFT, padx=5, pady=5)
    root.mainloop()
# Tính năng 10: Thời tiết 
CONFIG_FILE = "config.ini"
VALID_CITIES_FILE = "valid_cities.txt"
def thoi_tiet():
    def save_api_key(api_key):
        config = configparser.ConfigParser()
        config['Settings'] = {'API_Key': api_key}
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as configfile:
                config.write(configfile)
        except Exception as e:
            messagebox.showerror("Lỗi lưu", f"Không thể lưu mã API: {e}")

    def load_api_key():
        config = configparser.ConfigParser()
        if os.path.exists(CONFIG_FILE):
            config.read(CONFIG_FILE, encoding='utf-8')
            return config.get('Settings', 'API_Key', fallback="")
        return ""

    def save_valid_city(city):
        """Lưu tên thành phố vào file nếu chưa tồn tại."""
        if not os.path.exists(VALID_CITIES_FILE):
            with open(VALID_CITIES_FILE, 'w', encoding='utf-8') as file:
                file.write(f"{city}\n")
        else:
            with open(VALID_CITIES_FILE, 'r+', encoding='utf-8') as file:
                cities = file.read().splitlines()
                if city not in cities:
                    file.write(f"{city}\n")
                    city_listbox.insert(END, city)  # Thêm vào danh sách hiển thị

    def load_valid_cities():
        """Tải danh sách các tỉnh/thành phố đã nhập đúng."""
        if os.path.exists(VALID_CITIES_FILE):
            with open(VALID_CITIES_FILE, 'r', encoding='utf-8') as file:
                return file.read().splitlines()
        return []

    def get_weather_data():
        city = city_entry.get().strip()
        api_key = api_key_entry.get().strip()

        if not city:
            messagebox.showwarning("Lỗi", "Vui lòng nhập tên thành phố.")
            return

        if not api_key:
            messagebox.showwarning("Lỗi", "Vui lòng nhập mã API của bạn.")
            return
        
        save_api_key(api_key)

        city = unidecode(city)

        ow_url = "http://api.openweathermap.org/data/2.5/weather?"
        call_url = f"{ow_url}appid={api_key}&q={city}&units=metric"

        try:
            response = requests.get(call_url)
            data = response.json()

            if data["cod"] == 200:
                save_valid_city(city)  # Lưu thành phố hợp lệ vào danh sách

                weather_info = f"""
🌡️ Nhiệt độ: {data['main']['temp']}°C
🌬️ Áp suất: {data['main']['pressure']} hPa
💦 Độ ẩm: {data['main']['humidity']}%
☁️ Thời tiết: {data['weather'][0]['description'].capitalize()}
"""
                result_label.config(text=weather_info)
            else:
                result_label.config(text="Không tìm thấy địa chỉ.")
                messagebox.showerror("Lỗi", "Không tìm thấy thành phố, vui lòng kiểm tra lại.")

        except requests.exceptions.ConnectionError:
            messagebox.showerror("Lỗi mạng", "Không thể kết nối đến dịch vụ thời tiết, kiểm tra internet của bạn.")
        except Exception as e:
            messagebox.showerror("Lỗi", f"Có lỗi xảy ra: {e}")

    def select_city_from_list(event):
        """Cho phép chọn thành phố từ danh sách bên trái."""
        selected_city = city_listbox.get(city_listbox.curselection())
        city_entry.delete(0, END)
        city_entry.insert(0, selected_city)

    root = Tk()
    root.title("Ứng dụng thời tiết")
    root.geometry("500x300")

    # --- Giao diện ---
    left_frame = Frame(root)
    left_frame.pack(side=LEFT, padx=5, pady=5)

    Label(left_frame, text="Danh sách tỉnh/thành phố:", font=("Arial", 12)).pack()

    city_listbox = Listbox(left_frame, height=10, width=25)
    city_listbox.pack(pady=5)

    for city in load_valid_cities():
        city_listbox.insert(END, city)

    city_listbox.bind("<<ListboxSelect>>", select_city_from_list)

    right_frame = Frame(root)
    right_frame.pack(side=RIGHT, padx=10, pady=10)

    Label(right_frame, text="Nhập mã API:", font=("Arial", 12)).pack(pady=5)
    api_key_entry = Entry(right_frame, width=35, font=("Arial", 12), show="*")
    api_key_entry.pack(pady=5)

    saved_api_key = load_api_key()
    if saved_api_key:
        api_key_entry.insert(0, saved_api_key)

    Label(right_frame, text="Nhập tên thành phố:", font=("Arial", 12)).pack(pady=5)
    city_entry = Entry(right_frame, width=35, font=("Arial", 12))
    city_entry.pack(pady=5)

    Button(right_frame, text="Xem thời tiết", command=get_weather_data, font=("Arial", 12)).pack(pady=10)

    result_label = Label(right_frame, text="Thông tin thời tiết sẽ hiển thị tại đây.", font=("Arial", 10))
    result_label.pack(pady=10)

    root.mainloop()
# Tính năng 11: Thay đổi giao diện người dùng
def giao_dien():
    root= None
    def ap_dung_chu_de(background_color, foreground_color):
        global root
        if root:
            root.configure(bg=background_color)
            style = ttk.Style()
            style.configure(".", background=background_color, foreground=foreground_color, font=('Arial', 10), relief="raised", padding=8, borderwidth=2)
    def chon_mau():
        color_code = colorchooser.askcolor(title="Chọn màu nền tùy chỉnh")
        if color_code[1]:
            ap_dung_chu_de(color_code[1], "black")  # Mặc định chữ đen


    root = Toplevel()
    root.title("10. Thay đổi giao diện người dùngdùng")
    tinh_nang_10 = ttk.Frame(root, padding=15)
    tinh_nang_10.grid()
    ttk.Label(tinh_nang_10, text="Chọn Màu Giao diện:", font=('Arial', 14, 'bold')).grid(row=0, column=0, pady=10)
    ttk.Button(tinh_nang_10, text="Màu Tùy Chỉnh", command=chon_mau).grid(row=1, column=0, sticky="ew", pady=5)
    root.mainloop()
# Tính năng 12: Bảng tuần hoàn hóa học
def bang_tuan_hoan():
    root = Toplevel()
    root.title("11. Bảng tuần hoàn hóa học")
    # Tạo khung giao diện
    tinh_nang_11 = ttk.Frame(root, padding=10)
    tinh_nang_11.grid()
    try:
        image = Image.open(r"D:\file cũ\data\bang_tuan_hoan.jpg")  # Đường dẫn tuyệt đối
        image = image.resize((800, 442))  # Không cần ANTIALIAS với phiên bản Pillow mới
        photo = ImageTk.PhotoImage(image)
    except Exception as e:
        print("Lỗi khi mở hình ảnh:", e)
        return

    # Tạo nhãn và hiển thị hình ảnh
    label = ttk.Label(tinh_nang_11, image=photo)
    label.image = photo  # Giữ tham chiếu để tránh ảnh biến mất
    label.grid(row=0, column=0)

    # Chạy vòng lặp chính
    root.mainloop()
# Tính năng 13: Đôi lời của nhà sản xuất
def doi_loi():
    root = Toplevel()
    root.title("11. Đôi lời của nhà sản xuất")
    message = (
        "Chào mừng bạn đến với ứng dụng của chúng tôi!\n"
        "Chúng tôi hy vọng bạn sẽ tìm thấy những tính năng hữu ích và thú vị."
        "Nếu bạn có bất kỳ câu hỏi hoặc đề xuất nào, vui lòng liên hệ với chúng tôi.\n"
        "Cảm ơn bạn đã sử dụng ứng dụng!\n"
        "Nhà sản xuất : Đinh Viết Phúc và Ngô Văn Anh Khoa."
        
    )
    ttk.Label(root, text=message, wraplength=300, justify="center").pack(padx=20, pady=20)

root = Tk() 
root.title("App_đa_năng(beta)")
frm = ttk.Frame(root, padding=10)
frm.grid(row=0, column=0, sticky="nsew")

root.grid_rowconfigure(0, weight=1)    
root.grid_columnconfigure(0, weight=1) 

ttk.Label(frm, text="Menu", anchor="center", font=('Arial', 14, 'bold')).grid(column=0, row=0, columnspan=2, sticky="ew", pady=5) 
ttk.Button(frm, text="1.Đồng hồ và lịch", command=clock).grid(column=0, row=1, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="2.Máy ảnh", command=camera).grid(column=0, row=2, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="3.Gửi thư", command=gui_thu).grid(column=0, row=3, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="4.Máy tính", command=may_tinh).grid(column=0, row=4, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="5.Chuyển âm thanh thành văn bản", command=chuyen_am_thanh_thanh_van_ban).grid(column=0, row=5, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="6.Tìm kiếm thông tin ", command=tim_kiem_thong_tin).grid(column=0, row=6, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="7. Đồng hồ đếm ngược", command=dem_nguoc).grid(column=0, row=7, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="8. Máy phát nhạc và video ", command=may_phat_nhac_va_video).grid(column=0, row=8, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="9. Viết văn bản ", command=van_ban).grid(column=0, row=9, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="10. Thời tiết", command=thoi_tiet).grid(column=0, row=10, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="11.Thay đổi giao diện người dùng ", command=giao_dien).grid(column=0, row=11, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="12.Bảng tuần hoàn", command=bang_tuan_hoan).grid(column=0, row=12, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="13. Đôi lời của nhà sản xuất ", command=doi_loi).grid(column=0, row=13, columnspan=2, sticky="ew", pady=2)

frm.grid_columnconfigure(0, weight=1) 
frm.grid_columnconfigure(1, weight=1) 

root.mainloop()
