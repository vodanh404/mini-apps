# khai báo thư viện
import os
import cv2
import time
import calendar
import smtplib
import requests
import pygame
import subprocess
import json
import wikipedia
import configparser
from unidecode import unidecode
from tkinter import *
from datetime import datetime
from PIL import Image, ImageTk
from tkinter.scrolledtext import ScrolledText
from tkinter import Tk, ttk, LEFT, W, E, N, S, messagebox, filedialog, colorchooser, simpledialog, filedialog, Listbox, Scrollbar, WORD, END, scrolledtext
import speech_recognition as sr
import librosa
import soundfile as sf
import threading
from tqdm import tqdm 
# Tính năng 1: Đồng hồ và lịch
def clock():
    # Tạo cửa sổ chính
    root = Toplevel()
    root.title("1. Đồng hồ và lịch")
    tinh_nang_1 = ttk.Frame(root, padding=20)
    tinh_nang_1.grid()
    # Tạo các nhãn cho ngày, giờ và lịch
    hom_nay = ttk.Label(tinh_nang_1, text="", anchor="center", font=("Helvetica", 16))
    hom_nay.grid(column=0, row=0, columnspan=2, pady=5)
    thoi_gian = ttk.Label(tinh_nang_1, text="", anchor="center", font=("Helvetica", 24, "bold"))
    thoi_gian.grid(column=0, row=1, columnspan=2, pady=5)
    calendar_label = ttk.Label(tinh_nang_1, text="", anchor="center", justify=LEFT, font=("Courier New", 12))
    calendar_label.grid(column=0, row=2, columnspan=2, pady=5)
    def update_clock():
        # Lấy ngày và giờ hiện tại
        hom_nay_data = datetime.now().strftime("%d-%m-%Y")
        thoi_gian_data = datetime.now().strftime("%H:%M:%S")
        # Cập nhật các nhãn
        hom_nay.config(text=f"Ngày hôm nay: {hom_nay_data}")
        thoi_gian.config(text=f"Thời gian: {thoi_gian_data}")
        root.after(1000, update_clock)
    # Lấy lịch cả năm
    text_calendar = calendar.TextCalendar()
    year = datetime.now().year
    all_lich = text_calendar.formatyear(year)
    calendar_label.config(text=f"Lịch năm nay: {all_lich}")
    # Gọi hàm update_clock ban đầu để hiển thị đồng hồ ngay lập tức
    update_clock()
    root.mainloop()
# Tính năng 2: Máy ảnh
recording = False
video_writer = None
def camera():
    global recording, video_writer
    root = Toplevel()
    root.title("2. Máy ảnh")
    cap = cv2.VideoCapture(0)

    tinh_nang_2 = ttk.Frame(root, padding=20)
    tinh_nang_2.grid()
    label = Label(tinh_nang_2)
    label.grid(column=0, row=0, columnspan=2, sticky="ew")

    def update_frame():
        ret, frame = cap.read()
        if ret:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(frame)
            img_tk = ImageTk.PhotoImage(image=img)
            label.img_tk = img_tk
            label.config(image=img_tk)
            if recording and video_writer is not None:
                frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                video_writer.write(frame_bgr)
        root.after(10, update_frame)

    def on_closing():
        cap.release()
        if video_writer is not None:
            video_writer.release()
        root.destroy()

    def chup_anh():
        ret, frame = cap.read()
        if ret:
            filename = datetime.now().strftime("%Y%m%d_%H%M%S") + ".jpg"
            cv2.imwrite(filename, frame)
            print(f"Ảnh đã được lưu: {filename}")

    def quay_video():
        global recording, video_writer
        if not recording:
            recording = True
            filename = datetime.now().strftime("%Y%m%d_%H%M%S") + ".avi"
            fourcc = cv2.VideoWriter_fourcc(*'XVID')
            video_writer = cv2.VideoWriter(filename, fourcc, 20.0, (640, 480))
            print(f"Bắt đầu quay video: {filename}")
        else:
            recording = False
            if video_writer is not None:
                video_writer.release()
                print("Dừng quay video")
            video_writer = None

    def mo_kho_luu_tru():
        os.startfile(os.getcwd())

    ttk.Button(tinh_nang_2, text="Chụp ảnh", command=chup_anh).grid(column=0, row=1, columnspan=2, sticky="ew")
    ttk.Button(tinh_nang_2, text="Quay video", command=quay_video).grid(column=0, row=2, columnspan=2, sticky="ew")
    ttk.Button(tinh_nang_2, text="Kho lưu trữ", command=mo_kho_luu_tru).grid(column=0, row=3, columnspan=2, sticky="ew")

    root.protocol("WM_DELETE_WINDOW", on_closing)
    update_frame()
    root.mainloop()
# Tính năng 3: Gửi thư  
def gui_thu():
    SENDER_EMAIL = "ungdungthu3@gmail.com"
    SENDER_PASSWORD = "dvmq ponq gplj awdq"
    def send_email():
        try:
            server = smtplib.SMTP("smtp.gmail.com", 587)
            server.starttls()
            server.login(SENDER_EMAIL, SENDER_PASSWORD)
            email_message = f"Subject: {subject_entry.get()}\n\n{message_text.get('1.0', END)}".encode("utf-8")
            server.sendmail(SENDER_EMAIL, recipient_entry.get(), email_message)
            server.quit()
            messagebox.showinfo("Thành công", "Email đã được gửi!")
        except Exception as e:
            messagebox.showerror("Lỗi", f"Không thể gửi email: {e}")

    root = Toplevel()
    root.title("3.Gửi thư")

    Label(root, text="Người gửi:").grid(row=0, column=0)
    Label(root, text=SENDER_EMAIL).grid(row=0, column=1)

    Label(root, text="Người nhận:").grid(row=1, column=0)
    recipient_entry = Entry(root, width=40); recipient_entry.grid(row=1, column=1)

    Label(root, text="Chủ đề:").grid(row=2, column=0)
    subject_entry = Entry(root, width=40); subject_entry.grid(row=2, column=1)

    Label(root, text="Nội dung:").grid(row=3, column=0)
    message_text = Text(root, height=10, width=50); message_text.grid(row=3, column=1)

    Button(root, text="Gửi", command=send_email).grid(row=4, column=1)
    
    root.mainloop()
# Tính năng 4: Máy tính
def may_tinh():
    root = Toplevel()
    root.title("4. Máy tính")
    root.resizable(False, False)

    expression = ""     # Biến này để lưu trữ biểu thức hiện tại

    # Hàm cập nhật ô nhập liệu
    def update_entry(value):
        nonlocal expression
        expression += str(value)
        entry.delete(0, END)
        entry.insert(0, expression)
    # Hàm xóa toàn bộ ô nhập liệu 
    def clear_entry():
        nonlocal expression
        expression = ""
        entry.delete(0, END)
    # Hàm tính toán kết quả
    def calculate_result():
        nonlocal expression
        try:
            # Thay thế các ký hiệu toán học với người dùng thành toán tử Python
            eval_expression = expression.replace("x", "*").replace(":", "/").replace(",", ".")
            # Đánh giá biểu thức
            result = str(eval(eval_expression))
            entry.delete(0, END)
            entry.insert(0, result)
            expression = result # Lưu kết quả để có thể tiếp tục tính toán
        except Exception as e:
            # Hiển thị thông báo lỗi
            messagebox.showerror("Lỗi", "Biểu thức không hợp lệ hoặc lỗi: " + str(e))
            expression = "" # Đặt lại biểu thức khi có lỗi
    # Hàm xóa ký tự cuối cùng 
    def delete_last_char():
        nonlocal expression
        expression = expression[:-1] # Cắt bỏ ký tự cuối cùng
        entry.delete(0, END)
        entry.insert(0, expression)
    # Khung chứa các phím
    tinh_nang_4 = ttk.Frame(root, padding="10 10 10 10")
    tinh_nang_4.grid(row=0, column=0, sticky=(N, W, E, S))
    root.grid_columnconfigure(0, weight=1)
    root.grid_rowconfigure(0, weight=1)
    # Ô nhập liệu hiển thị biểu thức và kết quả
    entry = Entry(tinh_nang_4, width=25, font=('Arial', 14), justify='right')
    entry.grid(row=0, column=0, columnspan=5, pady=10, ipadx=5, ipady=5)
    # Các nút hàng 1
    ttk.Button(tinh_nang_4, text="AC", command=clear_entry, width=5).grid(column=0, row=1, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="(", command=lambda: update_entry("("), width=5).grid(column=1, row=1, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text=")", command=lambda: update_entry(")"), width=5).grid(column=2, row=1, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text=":", command=lambda: update_entry(":"), width=5).grid(column=3, row=1, padx=2, pady=2) 
    # Các nút hàng 2
    ttk.Button(tinh_nang_4, text="7", command=lambda: update_entry("7"), width=5).grid(column=0, row=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="8", command=lambda: update_entry("8"), width=5).grid(column=1, row=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="9", command=lambda: update_entry("9"), width=5).grid(column=2, row=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="x", command=lambda: update_entry("x"), width=5).grid(column=3, row=2, padx=2, pady=2) 
    # Các nút hàng 3
    ttk.Button(tinh_nang_4, text="4", command=lambda: update_entry("4"), width=5).grid(column=0, row=3, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="5", command=lambda: update_entry("5"), width=5).grid(column=1, row=3, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="6", command=lambda: update_entry("6"), width=5).grid(column=2, row=3, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="-", command=lambda: update_entry("-"), width=5).grid(column=3, row=3, padx=2, pady=2) 
    # Các nút hàng 4
    ttk.Button(tinh_nang_4, text="1", command=lambda: update_entry("1"), width=5).grid(column=0, row=4, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="2", command=lambda: update_entry("2"), width=5).grid(column=1, row=4, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="3", command=lambda: update_entry("3"), width=5).grid(column=2, row=4, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="+", command=lambda: update_entry("+"), width=5).grid(column=3, row=4, padx=2, pady=2) 
    # Các nút hàng 5
    ttk.Button(tinh_nang_4, text="0", command=lambda: update_entry("0"), width=11).grid(column=0, row=5, columnspan=2, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text=".", command=lambda: update_entry("."), width=5).grid(column=2, row=5, padx=2, pady=2)
    ttk.Button(tinh_nang_4, text="=", command=calculate_result, width=5).grid(column=3, row=5, padx=2, pady=2)
    # Nút xóa ký tự cuối cùng
    ttk.Button(tinh_nang_4, text="Xóa", command=delete_last_char, width=5).grid(column=4, row=1, padx=2, pady=2)
    root.mainloop()
# Tính năng 5: Chuyển âm thanh thành văn bản
def chuyen_am_thanh_thanh_van_ban():
    def update_progress(message):
        text_area.delete(1.0, END)
        text_area.insert(END, message + "\n")
        text_area.update_idletasks() # Đảm bảo giao diện người dùng cập nhật ngay lập tức

    def convert_audio_to_text(file_path=None, language="vi-VN", use_microphone=False):

        recognizer = sr.Recognizer()

        try:
            update_progress("Đang xử lý âm thanh...")

            if use_microphone:
                with sr.Microphone() as source:
                    update_progress("Nói vào micro...")
                    # Điều chỉnh tiếng ồn xung quanh trước khi lắng nghe
                    recognizer.adjust_for_ambient_noise(source)
                    # Lắng nghe đầu vào âm thanh từ micro
                    recorded_data = recognizer.listen(source)
            else:
                if not file_path:
                    update_progress("Lỗi: Không có đường dẫn file MP3.")
                    return

                update_progress("Đang tải file MP3 và chuyển đổi...")
                # Tải MP3 bằng librosa, giữ nguyên tốc độ mẫu gốc
                y, sr_rate = librosa.load(file_path, sr=None)
                # Ghi vào một file WAV tạm thời vì SpeechRecognition hoạt động tốt nhất với WAV
                sf.write("temp_audio.wav", y, sr_rate)

                # Mô phỏng thanh tiến trình cho quá trình xử lý file
                for i in range(1, 11): # Từ 10% đến 100%
                    update_progress(f"Tiến trình tải và xử lý: {i * 10}%")
                    time.sleep(0.1) # Tạm dừng nhỏ để hiển thị cập nhật tiến trình

                with sr.AudioFile("temp_audio.wav") as source:
                    # Ghi lại toàn bộ file âm thanh
                    recorded_data = recognizer.record(source)

            update_progress("Đang nhận dạng giọng nói... (Quá trình này có thể mất một chút thời gian)")
            # Sử dụng API Google Web Speech để nhận dạng
            text = recognizer.recognize_google(recorded_data, language=language)

            update_progress("Hoàn tất! Dưới đây là văn bản:")
            text_area.insert(END, f"\n{text}\n")
        except sr.UnknownValueError:
            update_progress("Không thể nhận dạng giọng nói. Vui lòng thử lại.")
        except sr.RequestError as e:
            update_progress(f"Không thể kết nối với dịch vụ nhận dạng giọng nói; {e}")
        except FileNotFoundError:
            update_progress("Lỗi: Không tìm thấy file âm thanh.")
        except Exception as e:
            # Bắt bất kỳ lỗi không mong muốn nào khác
            update_progress(f"Lỗi: {e}")

    def select_mp3_file(language="vi-VN"):
        # Yêu cầu người dùng chọn một file MP3
        file_path = filedialog.askopenfilename(
            title="Chọn file MP3",
            filetypes=[("MP3 files", "*.mp3"), ("Tất cả file", "*.*")]
        )
        if file_path:
            # Chạy quá trình chuyển đổi trong một luồng riêng biệt để giữ cho GUI phản hồi
            threading.Thread(target=convert_audio_to_text,
                             args=(file_path, language, False)).start()

    def start_microphone_recognition(language="vi-VN"):

        # Chạy nhận dạng micro trong một luồng riêng biệt
        threading.Thread(target=convert_audio_to_text,
                         args=(None, language, True)).start()

    # Thiết lập cửa sổ Tkinter chính
    root = Toplevel()
    root.title("5. Chuyển âm thanh thành văn bản")
    root.geometry("700x500") # Cửa sổ lớn hơn một chút

    # Cấu hình lưới để đáp ứng
    root.grid_rowconfigure(2, weight=1)
    root.grid_columnconfigure(0, weight=1)
    root.grid_columnconfigure(1, weight=1)

    # Khung chứa các nút
    button_frame = Frame(root, padx=10, pady=10)
    button_frame.grid(row=0, column=0, columnspan=2, pady=10, padx=10, sticky="ew")
    button_frame.grid_columnconfigure(0, weight=1)
    button_frame.grid_columnconfigure(1, weight=1)
    button_frame.grid_columnconfigure(2, weight=1)
    button_frame.grid_columnconfigure(3, weight=1)


    # Các nút để chọn file MP3 (tiếng Việt và tiếng Anh)
    select_button_vi = Button(button_frame, text="Chọn File MP3 (Tiếng Việt)",
                              command=lambda: select_mp3_file("vi-VN"),
                              font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    select_button_vi.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

    select_button_en = Button(button_frame, text="Chọn File MP3 (Tiếng Anh)",
                              command=lambda: select_mp3_file("en-US"),
                              font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    select_button_en.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    # Các nút để nhập từ Micro (tiếng Việt và tiếng Anh)
    mic_button_vi = Button(button_frame, text="Nhận dạng Micro (Tiếng Việt)",
                           command=lambda: start_microphone_recognition("vi-VN"),
                           font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    mic_button_vi.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

    mic_button_en = Button(button_frame, text="Nhận dạng Micro (Tiếng Anh)",
                           command=lambda: start_microphone_recognition("en-US"),
                           font=("Arial", 10), relief="raised") # Đã xóa thuộc tính màu
    mic_button_en.grid(row=1, column=1, padx=5, pady=5, sticky="ew")

    # Widget ScrolledText để hiển thị kết quả và tiến trình
    text_area = scrolledtext.ScrolledText(root, wrap=WORD, width=70, height=15,
                                          font=("Arial", 12), bg="#F8F8F8", fg="#333333",
                                          relief="sunken", borderwidth=2)
    text_area.grid(row=2, column=0, padx=10, pady=10, columnspan=2, sticky="nsew")
    text_area.insert(END, "Chào mừng! Nhấn một trong các nút trên để bắt đầu chuyển đổi âm thanh thành văn bản.\n")

    # Bắt đầu vòng lặp sự kiện Tkinter
    root.mainloop()
# Tính năng 6: Tìm kiếm thông tin
def tim_kiem_thong_tin():
    wikipedia.set_lang("vi")
    def lay_thong_tin():
        noi_dung_tim_kiem = o_nhap.get()
        if not noi_dung_tim_kiem:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, "Vui lòng nhập từ khóa tìm kiếm.")
            return

        try:
            tom_tat = wikipedia.summary(noi_dung_tim_kiem) 
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, tom_tat)
        except wikipedia.exceptions.PageError:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, f"Rất tiếc, tôi không tìm thấy thông tin về '{noi_dung_tim_kiem}'. Vui lòng thử từ khóa khác.")
        except wikipedia.exceptions.DisambiguationError as e:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, f"'{noi_dung_tim_kiem}' có thể có nhiều nghĩa. Vui lòng cụ thể hơn. Các lựa chọn: {e.options[:5]}...")
        except Exception as e:
            o_ket_qua.delete(1.0, END)
            o_ket_qua.insert(END, f"Đã xảy ra lỗi: {e}")

    # Tạo cửa sổ chính
    cua_so = Tk()
    cua_so.title("6.Tìm kiếm thông tin")
    cua_so.geometry("600x400")

    # Cấu hình trọng số cho grid để các cột và hàng có thể giãn nở
    cua_so.grid_columnconfigure(0, weight=1) # Làm cho cột 0 có thể giãn ngang
    cua_so.grid_rowconfigure(2, weight=1)   # Làm cho hàng 2 (chứa ô hiển thị kết quả) có thể giãn dọc

    # Tạo và đặt các widget sử dụng .grid()
    nhan_huong_dan = Label(cua_so, text="Nhập nội dung bạn muốn tìm hiểu:")
    nhan_huong_dan.grid(row=0, column=0, padx=10, pady=10, sticky="w") 

    o_nhap = Entry(cua_so, width=50)
    o_nhap.grid(row=1, column=0, padx=10, pady=5, sticky="ew") 
    o_nhap.bind("<Return>", lambda event=None: lay_thong_tin()) 

    nut_tim_kiem = Button(cua_so, text="Tìm kiếm", command=lay_thong_tin)
    nut_tim_kiem.grid(row=1, column=0, padx=10, pady=5, sticky="e") 

    o_ket_qua = ScrolledText(cua_so, wrap=WORD, width=70, height=15)
    o_ket_qua.grid(row=2, column=0, padx=10, pady=10, sticky="nsew") 
    cua_so.mainloop()
# Tính năng 7: Đồng hồ đếm ngược
def dem_nguoc():
    def start_countdown():
        try:
            seconds = int(entry.get())
            if seconds < 0:
                raise ValueError("Thời gian không thể âm.")
            countdown(seconds)
        except ValueError as e:
            messagebox.showerror("Lỗi", f"Vui lòng nhập một số hợp lệ: {e}")

    def countdown(seconds):
        if seconds >= 0:
            label.config(text=f"Đếm ngược: {seconds} giây")
            root.after(1000, countdown, seconds - 1)
        else:
            label.config(text="Hết giờ!")

    root = Toplevel()
    root.title("7. Đồng hồ đếm ngược")
    root.resizable(False, False)
    ttk.Label(root, text="Nhập thời gian (giây):").grid(column=0, row=0)
    entry = ttk.Entry(root); entry.grid(column=1, row=0)
    ttk.Button(root, text="Bắt đầu", command=start_countdown).grid(column=2, row=0)
    label = ttk.Label(root, text="Đếm ngược: 0 giây", font=("Helvetica", 16))
    label.grid(column=0, row=1, columnspan=3)    
# Tính năng 8: Máy phát nhạc
pygame.mixer.init() 
current_file = None
music_list = []
playing_index = -1
paused = False
root = None
listbox = None
file_label = None
play_pause_button = None
def may_phat_nhac_va_video():

    def load_music_list():      # Tải danh sách nhạc từ tệp JSON
        global music_list
        if os.path.exists("music_list.json"):
            with open("music_list.json", "r", encoding='utf-8') as f:
                try:
                    music_list = json.load(f)
                except json.JSONDecodeError:
                    music_list = []
            # Lọc bỏ các đường dẫn không tồn tại để tránh lỗi
                music_list = [path for path in music_list if os.path.exists(path)]

    def save_music_list():      #Lưu danh sách nhạc hiện tại vào tệp JSON
        global music_list
        with open("music_list.json", "w", encoding='utf-8') as f:
            json.dump(music_list, f, indent=4)

    def update_listbox():       #Cập nhật nội dung của widget listbox.
        global listbox
        listbox.delete(0,END)
        for i, path in enumerate(music_list):
            listbox.insert(END, f"{i+1}. {os.path.basename(path)}")
        highlight_playing_song()

    def highlight_playing_song():       # Đánh dấu bài hát đang phát trong listbox.
        global listbox, playing_index
        listbox.selection_clear(0,END)
        if 0 <= playing_index < len(music_list):
            listbox.selection_set(playing_index)
            listbox.see(playing_index)

    def add_to_music_list():        # Mở hộp thoại tệp để thêm các tệp nhạc vào danh sách phát.
        global music_list
        files_selected = filedialog.askopenfilenames(title="Chọn File Nhạc", filetypes=[("File nhạc (MP3, WAV)", "*.mp3;*.wav"), ("Tất cả", "*.*")])
        if files_selected:
            for file_path in files_selected:
                if file_path not in music_list: # Tránh thêm các bài hát trùng lặp
                    music_list.append(file_path)
            update_listbox()
            save_music_list()

    def remove_selected_from_list(event=None):      # Xóa các bài hát đã chọn khỏi danh sách phát.
        global music_list, playing_index, current_file, file_label
        selected_indices = listbox.curselection()
        if not selected_indices:
            messagebox.showinfo("Thông báo", "Vui lòng chọn bài hát để xóa.")
            return
    # Sắp xếp các chỉ mục để xóa theo thứ tự giảm dần để tránh thay đổi chỉ mục khi xóa
        indices_to_remove = sorted(list(selected_indices), reverse=True)
    # Đếm số lượng bài hát bị xóa *trước* bài hát đang phát để điều chỉnh playing_index
        removed_before_playing_count = 0
        original_playing_index = playing_index # Lưu chỉ mục gốc để so sánh
        for idx in indices_to_remove:
            if idx == original_playing_index: # Nếu bài hát đang phát bị xóa
                pygame.mixer.music.stop()
                current_file = None
                playing_index = -1 # Đặt lại playing_index
                file_label.config(text="Chưa có file nào được chọn")
                break # Bài hát đang phát đã được xử lý, không cần kiểm tra thêm
            if idx < original_playing_index:
                removed_before_playing_count += 1
    # Xóa các bài hát khỏi danh sách
        for index in indices_to_remove:
            del music_list[index]
    # Điều chỉnh playing_index sau khi xóa
        if playing_index != -1: # Nếu vẫn còn bài hát đang phát (tức là không bị xóa)
            playing_index -= removed_before_playing_count
    # Đảm bảo playing_index nằm trong giới hạn hợp lệ
            if playing_index >= len(music_list):
                playing_index = len(music_list) - 1 if len(music_list) > 0 else -1
            elif playing_index < 0 and len(music_list) > 0:
                playing_index = 0 # Đặt lại về bài hát đầu tiên nếu nó trở thành âm và vẫn còn bài hát
            elif len(music_list) == 0:
                playing_index = -1
        update_listbox()
        save_music_list()
        highlight_playing_song()

    def play_selected_from_list(event=None):        # Phát bài hát được chọn trong listbox.
        global playing_index, music_list
        selected_indices = listbox.curselection()
        if not selected_indices:
            return
        index = selected_indices[0]
        if 0 <= index < len(music_list):
            playing_index = index
            open_file(music_list[index])
            highlight_playing_song()

    def play_next():        # Phát bài hát tiếp theo trong danh sách phát.
        global music_list, playing_index
        if not music_list:
            messagebox.showinfo("Thông báo", "Danh sách phát trống.")
            return
        playing_index = (playing_index + 1) % len(music_list)
        open_file(music_list[playing_index])
        highlight_playing_song()

    def play_previous(): #Phát bài hát trước đó trong danh sách phát.
        global music_list, playing_index
        if not music_list:
            messagebox.showinfo("Thông báo", "Danh sách phát trống.")
            return
        playing_index = (playing_index - 1 + len(music_list)) % len(music_list)
        open_file(music_list[playing_index])
        highlight_playing_song()

    def select_and_open_file():
        global playing_index
        file_selected = filedialog.askopenfilenames(
            title="Chọn file",
            filetypes=[
                ("Tất cả file media", "*.mp3;*.wav;*.mp4;*.avi;*.mkv"),
                ("File nhạc (MP3, WAV)", "*.mp3;*.wav"),
                ("File video (MP4, AVI, MKV)", "*.mp4;*.avi;*.mkv"),
                ("Tất cả", "*.*")
            ]
        )
        if file_selected:
            playing_index = -1
            open_file(file_selected[0])  
            highlight_playing_song() 

    def open_file(file_path):       # Mở và phát tệp media đã chỉ định.
        global current_file, file_label, music_list, playing_index
        if not os.path.exists(file_path):
            messagebox.showerror("Lỗi", f"File không tồn tại: {file_path}")
        # Nếu tệp không tồn tại trong danh sách phát, hãy xóa nó
            if file_path in music_list:
                music_list.remove(file_path)
                update_listbox()
                save_music_list()
            current_file = None
            file_label.config(text="Chưa có file nào được chọn")
            return

        current_file = file_path
        file_name = os.path.basename(file_path)
        file_label.config(text=f"Đang phát: {file_name}")

        try:
            if file_path.lower().endswith(('.mp3', '.wav')):
                play_music(file_path)
            else:
                pygame.mixer.music.stop()
            # Sử dụng lệnh dành riêng cho từng hệ điều hành để mở các loại media khác
                if os.name == 'nt':  # Đối với Windows
                    os.startfile(file_path)
                elif os.uname().sysname == 'Darwin':  # Đối với macOS
                    subprocess.Popen(['open', file_path])
                else:  # Đối với Linux/Unix
                    subprocess.Popen(['xdg-open', file_path])
        except Exception as e:
            messagebox.showerror("Lỗi mở file", f"Lỗi: {e}")
            current_file = None
            file_label.config(text="Chưa có file nào được chọn")

    def play_music(music_path):     # Tải và phát tệp nhạc bằng pygame.mixer.
        global paused, play_pause_button, current_file, music_list, playing_index, root
        try:
            pygame.mixer.music.load(music_path)
            pygame.mixer.music.play()
            paused = False
            play_pause_button.config(text="Tạm Dừng")
            pygame.mixer.music.set_endevent(pygame.USEREVENT)
            root.after(100, check_music_end) # Bắt đầu kiểm tra xem bài hát đã kết thúc chưa
        except pygame.error as e:
            messagebox.showerror("Lỗi phát nhạc", f"Không thể phát nhạc: {e}")
            current_file = None
            file_label.config(text="Chưa có file nào được chọn")
        # Nếu bài hát có vấn đề là từ danh sách phát, hãy xóa nó
            if playing_index != -1 and music_list[playing_index] == music_path:
                del music_list[playing_index]
                update_listbox()
                save_music_list()
                playing_index = -1

    def check_music_end():      # Kiểm tra xem nhạc hiện tại đã kết thúc chưa và phát bài hát tiếp theo nếu có.
        global playing_index, music_list, current_file, file_label, root

        for event in pygame.event.get():
            if event.type == pygame.USEREVENT:
                if playing_index != -1 and playing_index < len(music_list) - 1:
                    play_next()
                else:
                # Kết thúc danh sách phát hoặc phát một bài hát duy nhất
                    pygame.mixer.music.stop()
                    current_file = None
                    file_label.config(text="Đã phát hết danh sách")
                    playing_index = -1
                    highlight_playing_song()
                return # Đã xử lý sự kiện, dừng kiểm tra trong lần lặp này

    # Tiếp tục kiểm tra chỉ khi nhạc đang bận hoặc tạm dừng
        if pygame.mixer.music.get_busy() or pygame.mixer.music.get_paused():
            root.after(100, check_music_end)

    def toggle_play_pause():        # Chuyển đổi trạng thái phát/tạm dừng của nhạc hiện tại.
        global current_file, music_list, playing_index, paused, play_pause_button
        if not current_file:
            if music_list:
                playing_index = 0
                open_file(music_list[playing_index])
                highlight_playing_song()
            else:
                messagebox.showinfo("Thông báo", "Vui lòng chọn một file nhạc trước.")
            return
        if paused:
            pygame.mixer.music.unpause()
            play_pause_button.config(text="Tạm Dừng")
            paused = False
        else:
            pygame.mixer.music.pause()
            play_pause_button.config(text="Tiếp Tục")
            paused = True

    def on_closing():       # Xử lý sự kiện đóng cửa sổ, lưu danh sách phát và dừng nhạc.
        global root
        save_music_list()
        pygame.mixer.music.stop()
        root.destroy()

    global root, listbox, file_label, play_pause_button

    root = Toplevel()
    root.title("8. Phát nhạc và video")
    tinh_nang_8 = ttk.Frame(root, padding=10)
    tinh_nang_8.grid(row=0, column=0, sticky="nsew")

    root.grid_rowconfigure(0, weight=1)
    root.grid_columnconfigure(0, weight=1)

    load_music_list()

    # --- Các phần tử giao diện người dùng ---

    # Nhãn tệp hiện tại
    file_label = Label(tinh_nang_8, text="Chưa có file nào được chọn", anchor="w")
    file_label.grid(row=0, column=0, columnspan=4, sticky="ew", pady=(0, 10))

    # Khung nút
    button_frame = ttk.Frame(tinh_nang_8)
    button_frame.grid(row=1, column=0, columnspan=4, pady=(0, 10))
    # Cấu hình các cột trong button_frame để mở rộng đều
    button_frame.grid_columnconfigure(0, weight=1)
    button_frame.grid_columnconfigure(1, weight=1)
    button_frame.grid_columnconfigure(2, weight=1)
    button_frame.grid_columnconfigure(3, weight=1)

    play_pause_button = ttk.Button(button_frame, text="Phát", command=toggle_play_pause)
    play_pause_button.grid(row=0, column=0, padx=5, sticky="ew")

    prev_button = ttk.Button(button_frame, text="Bài Trước", command=play_previous)
    prev_button.grid(row=0, column=1, padx=5, sticky="ew")

    next_button = ttk.Button(button_frame, text="Bài Kế", command=play_next)
    next_button.grid(row=0, column=2, padx=5, sticky="ew")

    open_file_button = ttk.Button(button_frame, text="Mở File", command=select_and_open_file)
    open_file_button.grid(row=0, column=3, padx=5, sticky="ew")

    # Nhãn danh sách phát
    playlist_label = ttk.Label(tinh_nang_8, text="Danh sách phát:", anchor="w")
    playlist_label.grid(row=2, column=0, columnspan=4, sticky="ew", pady=(10, 5))

    # Listbox cho danh sách nhạc
    listbox_frame = ttk.Frame(tinh_nang_8)
    listbox_frame.grid(row=3, column=0, columnspan=4, sticky="nsew")
    tinh_nang_8.grid_rowconfigure(3, weight=1)
    tinh_nang_8.grid_columnconfigure(0, weight=1) # Đảm bảo khung listbox mở rộng

    listbox = Listbox(listbox_frame, selectmode="extended")
    listbox.pack(side="left", fill="both", expand=True)

    scrollbar = Scrollbar(listbox_frame, orient="vertical", command=listbox.yview)
    scrollbar.pack(side="right", fill="y")
    listbox.config(yscrollcommand=scrollbar.set)

    # Ràng buộc double click để phát bài hát đã chọn
    listbox.bind("<Double-Button-1>", play_selected_from_list)

    # Các nút điều khiển danh sách phát
    playlist_button_frame = ttk.Frame(tinh_nang_8)
    playlist_button_frame.grid(row=4, column=0, columnspan=4, pady=(10, 0))
    # Cấu hình các cột trong playlist_button_frame
    playlist_button_frame.grid_columnconfigure(0, weight=1)
    playlist_button_frame.grid_columnconfigure(1, weight=1)


    add_to_list_button = ttk.Button(playlist_button_frame, text="Thêm vào DS", command=add_to_music_list)
    add_to_list_button.grid(row=0, column=0, padx=5, sticky="ew")

    remove_from_list_button = ttk.Button(playlist_button_frame, text="Xóa khỏi DS", command=remove_selected_from_list)
    remove_from_list_button.grid(row=0, column=1, padx=5, sticky="ew")

    # Cập nhật listbox ban đầu
    update_listbox()

    # Giao thức đóng cửa sổ
    root.protocol("WM_DELETE_WINDOW", on_closing)

    root.mainloop()
# Tính năng 9: Viết văn bản
def van_ban():
    root = Toplevel()
    root.title("9. Viết văn bản")
    text_area = Text(root, wrap="word", font=("Arial", 12))
    text_area.pack(expand=True, fill="both")
    
    def save_file():
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
        if file_path:
            with open(file_path, "w", encoding="utf-8") as file:
                file.write(text_area.get("1.0", END))
            messagebox.showinfo("Thông báo", "Tệp đã được lưu thành công.")
    
    def open_file():
        file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
        if file_path:
            with open(file_path, "r", encoding="utf-8") as file:
                text_area.delete("1.0", END)
                text_area.insert("1.0", file.read())
    
    ttk.Button(root, text="Lưu tệp", command=save_file).pack(side=LEFT, padx=5, pady=5)
    ttk.Button(root, text="Mở tệp", command=open_file).pack(side=LEFT, padx=5, pady=5)
    root.mainloop()
# Tính năng 10: Thời tiết 
CONFIG_FILE = "config.ini"
VALID_CITIES_FILE = "valid_cities.txt"
def thoi_tiet():
    def save_api_key(api_key):
        config = configparser.ConfigParser()
        config['Settings'] = {'API_Key': api_key}
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as configfile:
                config.write(configfile)
        except Exception as e:
            messagebox.showerror("Lỗi lưu", f"Không thể lưu khóa API: {e}")

    def load_api_key():
        config = configparser.ConfigParser()
        if os.path.exists(CONFIG_FILE):
            config.read(CONFIG_FILE, encoding='utf-8')
            return config.get('Settings', 'API_Key', fallback="")
        return ""

    def save_valid_city(city):
        """Lưu tên thành phố vào file nếu chưa tồn tại."""
        if not os.path.exists(VALID_CITIES_FILE):
            with open(VALID_CITIES_FILE, 'w', encoding='utf-8') as file:
                file.write(f"{city}\n")
        else:
            with open(VALID_CITIES_FILE, 'r+', encoding='utf-8') as file:
                cities = file.read().splitlines()
                if city not in cities:
                    file.write(f"{city}\n")
                    city_listbox.insert(END, city)  # Thêm vào danh sách hiển thị

    def load_valid_cities():
        """Tải danh sách các tỉnh/thành phố đã nhập đúng."""
        if os.path.exists(VALID_CITIES_FILE):
            with open(VALID_CITIES_FILE, 'r', encoding='utf-8') as file:
                return file.read().splitlines()
        return []

    def get_weather_data():
        city = city_entry.get().strip()
        api_key = api_key_entry.get().strip()

        if not city:
            messagebox.showwarning("Lỗi", "Vui lòng nhập tên thành phố.")
            return

        if not api_key:
            messagebox.showwarning("Lỗi", "Vui lòng nhập khóa API của bạn. Nếu chưa có vui lòng truy cập vào api.openweathermap.org để lấy khóa API miễn phí ")
            return
        
        save_api_key(api_key)

        city = unidecode(city)

        ow_url = "http://api.openweathermap.org/data/2.5/weather?"
        call_url = f"{ow_url}appid={api_key}&q={city}&units=metric"

        try:
            response = requests.get(call_url)
            data = response.json()

            if data["cod"] == 200:
                save_valid_city(city)  # Lưu thành phố hợp lệ vào danh sách

                weather_info = f"""
🌡️ Nhiệt độ: {data['main']['temp']}°C
🌬️ Áp suất: {data['main']['pressure']} hPa
💦 Độ ẩm: {data['main']['humidity']}%
☁️ Thời tiết: {data['weather'][0]['description'].capitalize()}
"""
                result_label.config(text=weather_info)
            else:
                result_label.config(text="Không tìm thấy địa chỉ.")
                messagebox.showerror("Lỗi", "Không tìm thấy thành phố, vui lòng kiểm tra lại.")

        except requests.exceptions.ConnectionError:
            messagebox.showerror("Lỗi mạng", "Không thể kết nối đến dịch vụ thời tiết, kiểm tra internet của bạn.")
        except Exception as e:
            messagebox.showerror("Lỗi", f"Có lỗi xảy ra: {e}")

    def select_city_from_list(event):
        """Cho phép chọn thành phố từ danh sách bên trái."""
        selected_city = city_listbox.get(city_listbox.curselection())
        city_entry.delete(0, END)
        city_entry.insert(0, selected_city)

    root = Tk()
    root.title("10.Thời tiết")
    root.geometry("500x300")

    # --- Giao diện ---
    left_frame = Frame(root)
    left_frame.pack(side=LEFT, padx=5, pady=5)

    Label(left_frame, text="Danh sách tỉnh/thành phố:", font=("Arial", 12)).pack()

    city_listbox = Listbox(left_frame, height=10, width=25)
    city_listbox.pack(pady=5)

    for city in load_valid_cities():
        city_listbox.insert(END, city)

    city_listbox.bind("<<ListboxSelect>>", select_city_from_list)

    right_frame = Frame(root)
    right_frame.pack(side=RIGHT, padx=10, pady=10)

    Label(right_frame, text="Nhập mã API:", font=("Arial", 12)).pack(pady=5)
    api_key_entry = Entry(right_frame, width=35, font=("Arial", 12), show="*")
    api_key_entry.pack(pady=5)

    saved_api_key = load_api_key()
    if saved_api_key:
        api_key_entry.insert(0, saved_api_key)

    Label(right_frame, text="Nhập tên thành phố:", font=("Arial", 12)).pack(pady=5)
    city_entry = Entry(right_frame, width=35, font=("Arial", 12))
    city_entry.pack(pady=5)

    Button(right_frame, text="Xem thời tiết", command=get_weather_data, font=("Arial", 12)).pack(pady=10)

    result_label = Label(right_frame, text="Thông tin thời tiết sẽ hiển thị tại đây.", font=("Arial", 10))
    result_label.pack(pady=10)

    root.mainloop()
# Tính năng 11: Thay đổi giao diện người dùng
def giao_dien():
    root= None
    def ap_dung_chu_de(background_color, foreground_color):
        global root
        if root:
            root.configure(bg=background_color)
            style = ttk.Style()
            style.configure(".", background=background_color, foreground=foreground_color, font=('Arial', 10), relief="raised", padding=8, borderwidth=2)
    def chon_mau():
        color_code = colorchooser.askcolor(title="Chọn màu nền tùy chỉnh")
        if color_code[1]:
            ap_dung_chu_de(color_code[1], "black")  # Mặc định chữ đen


    root = Toplevel()
    root.title("11. Thay đổi giao diện người dùng")
    tinh_nang_11 = ttk.Frame(root, padding=15)
    tinh_nang_11.grid()
    ttk.Label(tinh_nang_11, text="Chọn Màu Giao diện:", font=('Arial', 14, 'bold')).grid(row=0, column=0, pady=10)
    ttk.Button(tinh_nang_11, text="Màu Tùy Chỉnh", command=chon_mau).grid(row=1, column=0, sticky="ew", pady=5)
    root.mainloop()
# Tính năng 12: Bảng tuần hoàn hóa học
root = None
loading_frame = None
loading_label = None
cache_file = "periodic_table_data.json"
periodic_elements = []

periodic_table_frame = None
info_frame = None
info_text_area = None
def bang_tuan_hoan():

    def load_or_restore_element_data(url, current_loading_label, current_root):
        global periodic_elements

    # 1. Thử tải từ cache
        if os.path.exists(cache_file):
            try:
                current_loading_label.config(text="Đang tải dữ liệu từ cache...")
                current_root.update_idletasks()
                with open(cache_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                if 'elements' in data and isinstance(data['elements'], list):
                    periodic_elements = sorted(data['elements'], key=lambda x: x['number'])
                    current_loading_label.config(text="Đã tải dữ liệu từ cache.")
                    return True
                else:
                    print("Dữ liệu cache không hợp lệ, sẽ tải lại.")
            except (json.JSONDecodeError, IOError) as e:
                print(f"Lỗi khi đọc file cache: {e}. Sẽ thử tải lại từ internet.")
    # 2. Nếu không có cache hoặc cache bị lỗi, tải từ internet
        current_loading_label.config(text="Đang tải dữ liệu từ internet...")
        current_root.update_idletasks()
        try:
            response = requests.get(url, stream=True) # Use stream=True for progress
            response.raise_for_status()
        
            json_data_chunks = []
            for chunk in response.iter_content(chunk_size=8192):
                json_data_chunks.append(chunk)

            data = json.loads(b''.join(json_data_chunks).decode('utf-8'))
            periodic_elements = sorted(data['elements'], key=lambda x: x['number'])

            # Lưu dữ liệu vào cache
            try:
                with open(cache_file, 'w', encoding='utf-8') as f:
                    json.dump(data, f, indent=4, ensure_ascii=False)
                print(f"Đã lưu dữ liệu vào cache: {cache_file}")
            except IOError as e:
                print(f"Lỗi khi lưu dữ liệu vào cache: {e}")

            return True

        except requests.exceptions.RequestException as e:
            print(f"Lỗi khi tải dữ liệu từ internet: {e}")
            return False
        except json.JSONDecodeError as e:
            print(f"Lỗi giải mã JSON từ internet: {e}")
            return False     

    def create_widgets(current_root, current_loading_frame):
        global periodic_table_frame, info_frame, info_text_area

    # Ẩn khung tải
        current_loading_frame.destroy()

    # Cấu hình grid cho root window
        current_root.grid_rowconfigure(0, weight=1) # Hàng 0 sẽ giãn nở theo chiều dọc
        current_root.grid_columnconfigure(0, weight=4) # Cột 0 (khung bảng tuần hoàn) sẽ giãn nở nhiều hơn theo chiều ngang
        current_root.grid_columnconfigure(1, weight=1) # Cột 1 (khung thông tin) sẽ giãn nở ít hơn theo chiều ngang

    # Khung chứa bảng tuần hoàn
        periodic_table_frame = Frame(current_root, bg="#F0F0F0", padx=10, pady=10)
        periodic_table_frame.grid(row=0, column=0, sticky="nsew") # Đặt ở hàng 0, cột 0 và giãn nở

    # Khung hiển thị thông tin chi tiết nguyên tố
        info_frame = Frame(current_root, bg="#E0E0E0", width=300, padx=10, pady=10, bd=2, relief="groove")
        info_frame.grid(row=0, column=1, sticky="nsew") # Đặt ở hàng 0, cột 1 và giãn nở
        info_frame.grid_propagate(False) # Ngăn khung thông tin thay đổi kích thước

    # Cấu hình grid cho info_frame
        info_frame.grid_rowconfigure(1, weight=1) # Dòng cho info_text_area sẽ giãn nở
        info_frame.grid_columnconfigure(0, weight=1) # Cột duy nhất sẽ giãn nở

        info_label = Label(info_frame, text="Thông tin Nguyên tố", font=("Arial", 14, "bold"), bg="#E0E0E0", fg="#333333")
        info_label.grid(row=0, column=0, pady=10) # Đặt ở hàng 0, cột 0 trong info_frame

    # Vùng văn bản có thể cuộn để hiển thị thông tin chi tiết
        info_text_area = scrolledtext.ScrolledText(info_frame, wrap=WORD, font=("Arial", 10), width=35, height=25,
                                                   bg="#F8F8F8", fg="#000000", bd=1, relief="solid", padx=5, pady=5)
        info_text_area.grid(row=1, column=0, pady=5, sticky="nsew") # Đặt ở hàng 1, cột 0 và giãn nở
        info_text_area.config(state=DISABLED) # Ban đầu không cho chỉnh sửa

        display_periodic_table()
        add_category_legend()
    
    def display_periodic_table():
        # Cấu hình lưới cho periodic_table_frame để các hàng và cột giãn ra
        for i in range(10): # Có thể cần nhiều hàng hơn cho lanthanides/actinides
            periodic_table_frame.grid_rowconfigure(i, weight=1)
        for i in range(18): # 18 cột cho các nhóm
            periodic_table_frame.grid_columnconfigure(i, weight=1)

    # Định nghĩa vị trí bắt đầu cho Lanthanides và Actinides nếu hiển thị riêng
        lant_row_start = 8
        act_row_start = 9
        lant_act_col_offset = 3 # Cột bắt đầu tương đối

        for element in periodic_elements:
            symbol = element['symbol']
            atomic_number = element['number']
            category = element['category']
            period = element['period']
            xpos = element['xpos']
            ypos = element['ypos']

            background_color = get_color_by_category(category)

        # Điều chỉnh vị trí cho Lanthanides và Actinides
            if category in ["lanthanide", "actinide"]:
                if category == "lanthanide":
                    row = lant_row_start
                else: # actinide
                    row = act_row_start
            
            # Tính toán cột dựa trên số thứ tự trong series đó
                if atomic_number >= 57 and atomic_number <= 71: # Lanthanides
                    col = lant_act_col_offset + (atomic_number - 57)
                elif atomic_number >= 89 and atomic_number <= 103: # Actinides
                    col = lant_act_col_offset + (atomic_number - 89)
                else: # Các nguyên tố khác trong nhóm f-block nhưng không thuộc series chính
                    row = ypos - 1
                    col = xpos - 1
            else:
                row = ypos - 1 # ypos trong JSON bắt đầu từ 1
                col = xpos - 1 # xpos trong JSON bắt đầu từ 1

        # Tạo nút cho mỗi nguyên tố
            element_button = Button(periodic_table_frame,
                                    text=f"{atomic_number}\n{symbol}",
                                    command=lambda e=element: display_element_info(e),
                                    bg=background_color,
                                    fg="black",
                                    font=("Arial", 9, "bold"),
                                    width=5, height=3,
                                    bd=1, relief="raised")
            element_button.grid(row=row, column=col, padx=1, pady=1, sticky="nsew")

    # Thêm các nút giữ chỗ cho Lanthanides và Actinides ở vị trí ban đầu
        placeholder_la_button = Button(periodic_table_frame, text="57-71\nLa-Lu", bg="#D0D0D0", fg="black",
                                       font=("Arial", 9, "bold"), width=5, height=3, bd=1, relief="raised")
        placeholder_la_button.grid(row=5, column=2, padx=1, pady=1, sticky="nsew")

        placeholder_ac_button = Button(periodic_table_frame, text="89-103\nAc-Lr", bg="#D0D0D0", fg="black",
                                       font=("Arial", 9, "bold"), width=5, height=3, bd=1, relief="raised")
        placeholder_ac_button.grid(row=6, column=2, padx=1, pady=1, sticky="nsew")

    def get_color_by_category(category):
        colors = {
            "alkali metal": "#FF9999",          # Kim loại kiềm (Đỏ nhạt)
            "alkaline earth metal": "#FFCC99", # Kim loại kiềm thổ (Cam nhạt)
            "metalloid": "#FFFF99",             # Á kim (Vàng nhạt)
            "nonmetal": "#CCFFCC",              # Phi kim (Xanh lá nhạt)
            "noble gas": "#99CCFF",             # Khí hiếm (Xanh dương nhạt)
            "halogen": "#CC99FF",               # Halogen (Tím nhạt)
            "transition metal": "#FFCCCC",      # Kim loại chuyển tiếp (Hồng)
            "post-transition metal": "#CCCCFF", # Kim loại sau chuyển tiếp (Oải hương)
            "lanthanide": "#FFCCFF",            # Lanthanide (Hồng cánh sen nhạt)
            "actinide": "#FF99FF",              # Actinide (Hồng đậm hơn)
            "unknown, probably transition metal": "#D3D3D3", # Không xác định (Xám nhạt)
            "unknown, probably post-transition metal": "#D3D3D3", # Không xác định (Xám nhạt)
            "unknown, probably metalloid": "#D3D3D3", # Không xác định (Xám nhạt)
            "unknown, predicted to be noble gas": "#D3D3D3" # Không xác định (Xám nhạt)
        }
        return colors.get(category, "#E0E0E0") # Màu mặc định là xám nhạt

    def display_element_info(element):
    
        info_text = f"Tên: {element.get('name', 'N/A')}\n" \
                    f"Ký hiệu: {element.get('symbol', 'N/A')}\n" \
                    f"Số Nguyên Tử: {element.get('number', 'N/A')}\n" \
                    f"Khối Lượng Nguyên Tử: {element.get('atomic_mass', 'N/A')} u\n" \
                    f"Loại: {element.get('category', 'N/A').replace('_', ' ').title()}\n" \
                    f"Chu Kỳ: {element.get('period', 'N/A')}\n" \
                    f"Nhóm: {element.get('group', 'N/A')}\n"\
                    f"Điện Âm (Pauling): {element.get('electronegativity_pauling', 'N/A')}\n" \
                    f"Mật Độ: {element.get('density', 'N/A')} g/cm³\n" \
                    f"Điểm Nóng Chảy: {element.get('melt', 'N/A')} K\n" \
                    f"Điểm Sôi: {element.get('boil', 'N/A')} K\n" \
                    f"Người Phát Hiện: {element.get('discovered_by', 'N/A')}"

        info_text_area.config(state=NORMAL) # Cho phép chỉnh sửa tạm thời để cập nhật nội dung
        info_text_area.delete(1.0, END) # Xóa nội dung cũ
        info_text_area.insert(END, info_text) # Chèn thông tin mới
        info_text_area.config(state=DISABLED) # Khóa lại sau khi cập nhật

    def add_category_legend():
        """Thêm chú giải màu sắc cho các loại nguyên tố."""
        legend_frame = Frame(info_frame, bg="#E0E0E0", pady=10)
        legend_frame.grid(row=2, column=0, sticky="ew") # Đặt ở hàng 2, cột 0 trong info_frame và giãn nở

    # Tiêu đề chú giải
        Label(legend_frame, text="Chú Giải Màu Sắc:", font=("Arial", 11, "bold"), bg="#E0E0E0").grid(row=0, column=0, columnspan=2, pady=5, sticky="w")

    # Định nghĩa các loại nguyên tố và tên hiển thị tiếng Việt
        categories = {
            "kim loại kiềm": "alkali metal",
            "kim loại kiềm thổ": "alkaline earth metal",
            "á kim": "metalloid",
            "phi kim": "nonmetal",
            "khí hiếm": "noble gas",
            "halogen": "halogen",
            "kim loại chuyển tiếp": "transition metal",
            "kim loại sau chuyển tiếp": "post-transition metal",
            "lanthanide": "lanthanide",
            "actinide": "actinide",
            "không xác định": "unknown, probably transition metal" # Dùng một màu đại diện cho unknown
        }

        row_idx = 1 # Bắt đầu từ hàng 1, vì hàng 0 là tiêu đề chú giải
        for display_name, category_key in categories.items():
            color = get_color_by_category(category_key)
        
        # Ô màu sắc
            Label(legend_frame, bg=color, width=3, height=1, bd=1, relief="solid").grid(row=row_idx, column=0, padx=5, pady=1, sticky="w")
        # Nhãn văn bản
            Label(legend_frame, text=display_name.title(), font=("Arial", 9), bg="#E0E0E0").grid(row=row_idx, column=1, padx=0, pady=1, sticky="w")
            row_idx += 1

        legend_frame.grid_columnconfigure(1, weight=1) # Cho phép cột chứa văn bản giãn nở

    global root, loading_frame, loading_label

    root = Toplevel()
    root.title("12.Bảng Tuần Hoàn Hóa Học")
    root.geometry("1200x800")
    root.configure(bg="#F0F0F0")

    # Khung chứa thông báo tải dữ liệu ban đầu
    loading_frame = Frame(root, bg="#F0F0F0")
    loading_frame.pack(expand=True, fill=BOTH) # Vẫn dùng pack cho khung tải ban đầu để dễ dàng căn giữa

    loading_label = Label(loading_frame, text="Đang khởi tạo...", font=("Arial", 16, "bold"), bg="#F0F0F0")
    loading_label.pack(pady=50)

    # Cập nhật giao diện để hiển thị khung tải ngay lập tức
    root.update_idletasks()

    # Tải hoặc khôi phục dữ liệu nguyên tố
    data_loaded_successfully = load_or_restore_element_data(
        "https://raw.githubusercontent.com/Bowserinator/Periodic-Table-JSON/master/PeriodicTableJSON.json",
        loading_label, root
    )

    if not data_loaded_successfully:
        messagebox.showerror("Lỗi", "Không thể tải hoặc khôi phục dữ liệu bảng tuần hoàn. Vui lòng kiểm tra kết nối internet hoặc file cache.")
        root.destroy()
        return
    
    # Tạo và hiển thị các widgets chính sau khi tải dữ liệu
    # loading_frame sẽ bị hủy bỏ và các widget chính sẽ dùng grid
    create_widgets(root, loading_frame)

    root.mainloop()

# Tính năng 13: Đôi lời của nhà sản xuất
def doi_loi():
    root = Toplevel()
    root.title("13. Lời nhắn từ nhà phát triển") # Tiêu đề thân thiện hơn
    
    # Định nghĩa nội dung thông điệp
    message = (
        "Chào mừng bạn đến với ứng dụng của chúng tôi!\n\n" # Thêm dòng trống để dễ đọc
        "Chúng tôi đã tạo ra ứng dụng này với mong muốn mang lại những tính năng hữu ích "
        "và trải nghiệm thú vị cho bạn.\n\n" # Ngắt dòng hợp lý
        "Nếu bạn có bất kỳ câu hỏi, góp ý, hoặc cần hỗ trợ, "
        "xin đừng ngần ngại liên hệ với chúng tôi.\n\n" # Lời kêu gọi hành động rõ ràng
        "Chân thành cảm ơn bạn đã tin tưởng và sử dụng ứng dụng!\n\n"
        "Trân trọng,\n\n"
        "Đội ngũ phát triển: Đinh Viết Phúc và Ngô Văn Anh Khoa." 
    )
    ttk.Label(root, 
              text=message, 
              wraplength=400, 
              justify="left", 
              font=("Arial", 10)).pack(padx=20, pady=20) 
    
    root.mainloop()

root = Tk() 
root.title("App_đa_năng(beta)")
frm = ttk.Frame(root, padding=10)
frm.grid(row=0, column=0, sticky="nsew")

root.grid_rowconfigure(0, weight=1)    
root.grid_columnconfigure(0, weight=1) 

ttk.Label(frm, text="Menu", anchor="center", font=('Arial', 14, 'bold')).grid(column=0, row=0, columnspan=2, sticky="ew", pady=5) 
ttk.Button(frm, text="1.Đồng hồ và lịch", command=clock).grid(column=0, row=1, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="2.Máy ảnh", command=camera).grid(column=0, row=2, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="3.Gửi thư", command=gui_thu).grid(column=0, row=3, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="4.Máy tính", command=may_tinh).grid(column=0, row=4, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="5.Chuyển âm thanh thành văn bản", command=chuyen_am_thanh_thanh_van_ban).grid(column=0, row=5, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="6.Tìm kiếm thông tin ", command=tim_kiem_thong_tin).grid(column=0, row=6, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="7. Đồng hồ đếm ngược", command=dem_nguoc).grid(column=0, row=7, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="8. Máy phát nhạc và video ", command=may_phat_nhac_va_video).grid(column=0, row=8, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="9. Viết văn bản ", command=van_ban).grid(column=0, row=9, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="10. Thời tiết", command=thoi_tiet).grid(column=0, row=10, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="11.Thay đổi giao diện người dùng ", command=giao_dien).grid(column=0, row=11, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="12.Bảng tuần hoàn hóa học", command=bang_tuan_hoan).grid(column=0, row=12, columnspan=2, sticky="ew", pady=2)
ttk.Button(frm, text="13. Đôi lời của nhà sản xuất ", command=doi_loi).grid(column=0, row=13, columnspan=2, sticky="ew", pady=2)

frm.grid_columnconfigure(0, weight=1) 
frm.grid_columnconfigure(1, weight=1) 

root.mainloop()
